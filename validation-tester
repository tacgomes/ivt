#!/usr/bin/env python

import sys
import re
import subprocess
import shlex
import optparse


def run_command(cmd, error_strings, should_succeed):
    print "Running", cmd, should_succeed
    process = subprocess.Popen(shlex.split(cmd),
                               stdout=subprocess.PIPE,
                               stderr=subprocess.PIPE)
    outdata, errdata = process.communicate()
    test_failed = False
    if should_succeed == True and process.returncode != 0:
        test_failed = True
    if should_succeed == False:
        if process.returncode == 0:
            test_failed = True
        if error_strings:
            for es in error_strings:
                 if es in errdata:
                     break
            else:
                test_failed = True
    if test_failed:
        sys.stderr.write("    Failed.\n")
        sys.exit(1)


def validate_cmd(line, regex_dict, ranges_dict, enum_dict,
                 error_strings, optionals, should_succeed):
    key_value_match=re.search('(-{1,2}\w+)=(\$\w+)' ,line)
    # Test whether it is an optional parameter
    match = re.search(r'\[(.*?\$\w+.*?)\]',line)
    if match:
        l2 = line.replace(match.group(0), "", 1)
        match2=re.search('(\w+)=(\$\w+)', match.group(1))
        optionals.append(match2.group(1))
        validate_cmd(l2, regex_dict, ranges_dict, enum_dict,
            error_strings, optionals, should_succeed)
        l2 = line.replace(match.group(0), match.group(1), 1)
        validate_cmd(l2, regex_dict, ranges_dict, enum_dict,
            error_strings, optionals, should_succeed)
    elif key_value_match:
        var_name=key_value_match.group(2)
        if var_name[1:] not in optionals:
            l2 = line.replace(key_value_match.group(), "", 1)
            validate_cmd(l2, regex_dict, ranges_dict, enum_dict,
                         error_strings, optionals, False)
            l2 = line.replace(key_value_match.group(2), "", 1)
            validate_cmd(l2, regex_dict, ranges_dict, enum_dict,
                         error_strings, optionals, False)
        if var_name[1:] in regex_dict:
            test_strings = [-1, 0, 1, 1000, 1.0, "", "foo", "bar qux"]
            for ts in test_strings:
                l2 = line.replace(var_name, "'" + str(ts) + "'", 1)
                regex=regex_dict[var_name[1:]]
                matches2=re.search(regex,str(ts))
                if matches2:
                    validate_cmd(l2, regex_dict, ranges_dict, enum_dict,
                                 error_strings, optionals, should_succeed)
                else:
                    validate_cmd(l2, regex_dict, ranges_dict, enum_dict,
                                 error_strings, optionals, False)
        elif var_name[1:] in ranges_dict:
            (min_value, max_value) = ranges_dict[var_name[1:]]
            if min_value:
                l2 = line.replace(var_name, str(min_value), 1)
                validate_cmd(l2, regex_dict, ranges_dict, enum_dict,
                             error_strings, optionals, should_succeed)
                l2 = line.replace(var_name, str(min_value - 1), 1)
                validate_cmd(l2, regex_dict, ranges_dict, enum_dict,
                             error_strings, optionals, False)
            if max_value:
                l2 = line.replace(var_name, str(max_value), 1)
                validate_cmd(l2, regex_dict, ranges_dict, enum_dict,
                             error_strings, optionals, should_succeed)
                l2 = line.replace(var_name, str(max_value + 1), 1)
                validate_cmd(l2, regex_dict, ranges_dict, enum_dict,
                             error_strings, optionals, False)
        elif var_name[1:] in enum_dict:
            for enum in enum_dict[var_name[1:]]:
                l2 = line.replace(var_name, "'" + enum + "'", 1)
                validate_cmd(l2, regex_dict, ranges_dict, enum_dict,
                             error_strings, optionals, should_succeed)
            l2 = line.replace(var_name, "'not-existet-enum'", 1)
            validate_cmd(l2, regex_dict, ranges_dict, enum_dict,
                         error_strings, optionals, False)
        else:
            sys.stderr.write("Error: variable '{0}' is undefined\n".format(
                             var_name))
            sys.exit(1)
    else:
        run_command(line, error_strings, should_succeed)


def proccess_line(line, cmd_lines, regex_dict, ranges_dict,
                  enum_dict):
    if line.startswith('regex'):
        match = re.match("regex\W*(.+)=(.+)", line)
        regex_dict[match.group(1)] = match.group(2)
    elif line.startswith('range'):
        match = re.match("range\W*(.+)=(.+)", line)
        var_name = match.group(1)
        ranges = match.group(2)
        match = re.match("(\d*)\.\.(\d*)", ranges)
        lower_limit = None
        upper_limit = None
        if match.group(1):
            lower_limit = int(match.group(1))
        if match.group(2):
            upper_limit = int(match.group(2))
        ranges_dict[var_name] = (lower_limit, upper_limit)
    elif line.startswith('enum'):
        match = re.match("enum\W*(.+)=(.+)", line)
        var_name = match.group(1)
        enum_values=match.group(2).split(',')
        enum_dict[var_name] = enum_values
        pass
    elif not line.strip() or line.startswith('#'):
        pass
    else:
        cmd_lines.append(line)


def main():
    parser = optparse.OptionParser(usage='%prog [options] <arg1> [<arg2>...]')
    parser.add_option('-s', '--error-string', action="append", default=[],
                      help="Error string to match")
    options, files = parser.parse_args()
    if len(files) != 1:
        parser.error("wrong number of arguments")
    cmd_lines = []
    regex_dict = {}
    ranges_dict = {}
    enum_dict = {}
    for filename in files:
        with open(filename, 'r') as f:
            for line in f.read().splitlines():
                proccess_line(line, cmd_lines, regex_dict, ranges_dict,
                              enum_dict)
    print regex_dict
    print ranges_dict
    print enum_dict
    print cmd_lines
    for cmd_line in cmd_lines:
        validate_cmd(cmd_line, regex_dict, ranges_dict, enum_dict,
                     options.error_string, [], True)


if __name__ == "__main__":
    main()
