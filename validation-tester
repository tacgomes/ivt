#!/usr/bin/env python3

import sys
import re
import subprocess
import shlex
import argparse
import locale


class VarDict(dict):

     def __init__(self, *arg, **kw):
        super(VarDict, self).__init__(*arg, **kw)

     def is_regex(self, k):
         return isinstance(self.get(k), str)

     def is_range(self, k):
         return isinstance(self.get(k), tuple)

     def is_enum(self, k):
         return isinstance(self.get(k), list)


def run_command(cmd, ns, should_succeed):
    debug_str = ' '.join(["Running", cmd, str(should_succeed)])
    if ns.verbose:
        print (debug_str)
    process = subprocess.Popen(shlex.split(cmd),
                               stdout=subprocess.PIPE,
                               stderr=subprocess.PIPE)
    outdata, errdata = process.communicate()
    encoding = locale.getdefaultlocale()[1]
    test_failed = False
    if should_succeed and process.returncode != 0:
        test_failed = True
    if not should_succeed:
        if process.returncode == 0:
            test_failed = True
        if ns.error_string:
            for es in ns.error_string:
                 if es in errdata.decode(encoding):
                     break
            else:
                test_failed = True
    if test_failed:
        if not ns.quiet:
            if not ns.verbose:
                print (debug_str)
            sys.stderr.write("    Failed.\n")
        sys.exit(1)


def validate_cmd(line, var_dict, ns, optional_params, should_succeed):
    optional_param_match = re.search(r'\[(.*?\$\w+.*?)\]',line)
    key_value_match=re.search('(-{1,2}\w+)=(\$\w+)', line)
    if optional_param_match:
        aux_match=re.search('(\w+)=(\$\w+)', optional_param_match
                            .group(1))
        optional_params.append(aux_match.group(1))
        # Validate command without the optional setting
        l2 = line.replace(optional_param_match.group(0), "", 1)
        validate_cmd(l2, var_dict, ns, optional_params, should_succeed)
        # Validate command with the optional setting
        l2 = line.replace(optional_param_match.group(0),
                          optional_param_match.group(1), 1)
        validate_cmd(l2, var_dict, ns, optional_params, should_succeed)
    elif key_value_match:
        var_name=key_value_match.group(2)
        if key_value_match.group(1).lstrip('-') not in optional_params:
            l2 = line.replace(key_value_match.group(), "", 1)
            validate_cmd(l2, var_dict, ns, optional_params, False)
            l2 = line.replace('=' + key_value_match.group(2), "", 1)
            validate_cmd(l2, var_dict, ns, optional_params, False)
        # Replace the equals sign by a space, as it will work for both
        # short and GNU long options
        line = line.replace(key_value_match.group(0),
                            ' '.join(key_value_match.groups()), 1)
        if var_dict.is_regex(var_name[1:]):
            test_strings = [-1, 0, 1, 1000, 1.0, "", "foo", "bar qux"]
            for ts in test_strings:
                l2 = line.replace(var_name, "'" + str(ts) + "'", 1)
                regex=var_dict[var_name[1:]]
                matches2=re.search(regex,str(ts))
                if matches2:
                    validate_cmd(l2, var_dict, ns, optional_params,
                                 should_succeed)
                else:
                    validate_cmd(l2, var_dict, ns, optional_params, False)
        elif var_dict.is_range(var_name[1:]):
            (min_value, max_value) = var_dict[var_name[1:]]
            if min_value:
                l2 = line.replace(var_name, str(min_value), 1)
                validate_cmd(l2, var_dict, ns, optional_params,
                             should_succeed)
                l2 = line.replace(var_name, str(min_value - 1), 1)
                validate_cmd(l2, var_dict, ns, optional_params, False)
            if max_value:
                l2 = line.replace(var_name, str(max_value), 1)
                validate_cmd(l2, var_dict, ns, optional_params,
                             should_succeed)
                l2 = line.replace(var_name, str(max_value + 1), 1)
                validate_cmd(l2, var_dict, ns, optional_params, False)
        elif var_dict.is_enum(var_name[1:]):
            for enum in var_dict[var_name[1:]]:
                l2 = line.replace(var_name, "'" + enum + "'", 1)
                validate_cmd(l2, var_dict, ns, optional_params,
                             should_succeed)
            l2 = line.replace(var_name, "'not-existet-enum'", 1)
            validate_cmd(l2, var_dict, ns, optional_params, False)
        else:
            sys.stderr.write("Error: variable '{}' is undefined\n"
                             .format(var_name))
            sys.exit(1)
    else:
        run_command(line, ns, should_succeed)


def proccess_line(line, cmd_lines, var_dict):
    if line.startswith('regex'):
        match = re.match("regex\W*(.+)=(.+)", line)
        var_dict[match.group(1)] = '^' + match.group(2) + '$'
    elif line.startswith('range'):
        match = re.match("range\W*(.+)=(.+)", line)
        var_name = match.group(1)
        ranges = match.group(2)
        match = re.match("(\d*)\.\.(\d*)", ranges)
        lower_limit = None
        upper_limit = None
        if match.group(1):
            lower_limit = int(match.group(1))
        if match.group(2):
            upper_limit = int(match.group(2))
        var_dict[var_name] = (lower_limit, upper_limit)
    elif line.startswith('enum'):
        match = re.match("enum\W*(.+)=(.+)", line)
        var_name = match.group(1)
        enum_values=match.group(2).split(',')
        var_dict[var_name] = enum_values
        pass
    elif not line.strip() or line.startswith('#'):
        pass
    else:
        cmd_lines.append(line)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-s', '--error-string', action="append",
                        default=[], help="error string to match")
    parser.add_argument('files', nargs='+', help="list of spec files")
    group = parser.add_mutually_exclusive_group()
    group.add_argument('--quiet', action='store_true',
                       help="don't show any output")
    group.add_argument('--verbose', action='store_true',
                       help="activate verbose output")
    namespace = parser.parse_args()

    if not len(namespace.files):
        parser.error("wrong number of arguments")
    cmd_lines = []
    var_dict = VarDict()
    for filename in namespace.files:
        with open(filename, 'r') as f:
            for line in f.read().splitlines():
                proccess_line(line, cmd_lines, var_dict)

    if namespace.verbose:
        print (var_dict)
        print (cmd_lines)

    for cmd_line in cmd_lines:
        validate_cmd(cmd_line, var_dict, namespace, [], True)


if __name__ == "__main__":
    main()
